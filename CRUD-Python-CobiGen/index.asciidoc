= Create a CRUD Python Flask application using CobiGen's OpenAPI plugin
====

The aim of this tutorial is to create a basic CRUD Python Flask application from a single OpenAPI .yml file declaring an entity. 

The code will be generated using devonfw's CobiGen. This will result in a basic application layout, the declaration of a Flask-SQLAlchemy table with the entity's attributes as columns, and a service returning JSON objects for the GET, POST, PUT and DELETE methods.

### Prerequisites:

* devonfw workspace set up, including the CobiGen code generator and the corresponding `CobiGen_Templates` folder.
* Python 3 

====

[step]
--
nextKatacodaStep("Clone the templates folder", [{ "file": "files/clonetemplatesfolder.md" }])
--


We shall now return to:

`C:\Users\[yourName]\.cobigen\templates\CobiGen_Templates\src\main\templates`

Inspect the `context.xml` file. For code generation purposes, this lists a trigger for each template folder available to CobiGen. 

We need to edit this file by adding another trigger referring to our new `CRUD-openapi-python` folder. On Visual Studio, for instance, paste at the top of the trigger list the contents from `pythonTrigger.xml`:

[step]

--
createFile("main/pythonTrigger.xml", "files/pythonTrigger.xml")
--

We now have our `CobiGen_Templates` folder all set up. Next, head to the `\workspaces\main` folder in the devonfw environment. 

The only thing we are missing now is a .yml input in v3.0.0 format declaring a component and its properties. Take `user.yaml` as an example.

[step]
--
createFile("main/cobigen-python-example/user.yml", "files/user.yml")
--


Inspect `user.yml`. Note that the entity is declared under the `components: schemas:` section. In this case, we declared four typed attributes. 

Properties called `id` will be ignored, since the code generator automatically sets `id` as the table's primary key.

Besides the type, the project considers the following constraints:

* *maxLength*
* *uniqueItems*: sets `unique=True` for the column declaration.
* *required*: sets `nullable=False` for the column declaration.

====

Now open the command line at your project folder. You can check whether the CobiGen CLI is properly set up by running `devon cobigen`.

Let's generate the code now. Type:

[step]
--
executeCommand("cobigen generate user.yml","cobigen generate user.yml")
installCobiGen()
--  


If the command is not working properly you might want to run `cobigen update` or `cobigen adapt-templates` first. 

Otherwise the command line should return a full list of the available increments. 

Assuming that the `context.xml` and `templates.xml` files were properly set up, this should include the "CRUD Python Flask" option. Select this option. The command line should print out "Successful generation" shortly.


Now open the folder containing the .yml input on Visual Studio, for instance. Observe that Cobigen has generated and named the five files mentioned above. We are now set to run the application.

The safest way to install the required packages is to do so locally, by setting up a virtual environment. 

executeCommand(".\venv\Scripts\activate",".\venv\Scripts\activate")

[step]
--
executeCommand("python -m pip install virtualenv","python -m pip install virtualenv")

executeCommand("pip install -r requirements.txt","pip install -r requirements.txt")
--  


You should now see a new "venv" folder in your package explorer. To check whether the virtual environment activated properly make sure the terminal is printing "(venv)", followed by your directory.

If any packages failed to install automatically, try to do so manually. 


Let's initialize the database now.

[step]
--
executeCommand("flask db init","flask db init")
executeCommand("flask db migrate -m 'first migration'","flask db migrate -m 'first migration'")
executeCommand("flask db upgrade","flask db upgrade")
--  

This should create the `migrations` folder and the respective `__pycache__` folders in your directory. 

In order to upload the table declared in our "Model.py" we need a migration script. This command requires an attached message whenever it runs.

In this case, the terminal should print in return `Detected added table user`, among others.

The migration script can be then uploaded. This way our database is all set up. 



[step]
--
executeCommand("flask run","flask run")
nextKatacodaStep("Test on Postman", [{ "file": "files/postmantest.md" }])
--